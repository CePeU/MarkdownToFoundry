import { FoundryHtmlLinkInformation, FoundryHtml, generateIdForFile, Foundry } from "./foundry";
import { MarkdownToFoundrySettings } from "./settings";
import { isEmpty, removeEmptyLines, ObsidianPicture,debug } from "./utils";
import { App, TFile, Vault, Platform, normalizePath, parseFrontMatterEntry, FileSystemAdapter } from "obsidian";

/**
 * runs a few steps to clean the HTML generated by Obsidian's internal markdown renderer.
 *
 * @param parent the root element of the rendered HTML
 * @param settings the settings of the plugin
 */

// main function to clean the html. Each function is called and inside the function the check is performed to return or execute
export async function cleanHtml(parent: HTMLElement, settings: MarkdownToFoundrySettings, sourceFile: TFile): Promise<FoundryHtml> {
  // TODO: Create a setting to leave it to the user to define the order in which to do the cleaning
  let FoundryHtml: FoundryHtml = {
    html: "",
    foundryLinks: [],
    obsidianFileObj: sourceFile,
    obsidianUUID: "",
  };
  await convertImages(parent, settings, sourceFile); //convert image paths in html or convert to base64
  FoundryHtml.foundryLinks = resolveInternalLinks(parent, settings, sourceFile); // resolve links in html to full internal links
  replaceTag(parent, settings); //replace one tag with the other tag
  removeEmptyContainer(parent); // remove empty nodes/containers
  removeFrontMatter(parent, settings); // remove frontmatter header of html
  removeAttributes(parent, settings); //removeClasses(parent, settings);
  //TODO: Create new attributes based on regex

  //up to here html is a node list now it becomes a string
  let html = parent?.innerHTML ?? "";
  //html = replacePictureLinks(html,settings)
  html = replaceInHTMLWithRegex(parent.innerHTML, settings); //use regex to modify html string in a last step
  html = removeEmptyLines(html); // remove empty lines in html string
  if (settings.jsCode) {
    const scriptApi = {
      // add a property/function for the scriptApi object which goes into the JavaScript execution
      createID: () => {
        return Foundry.generateFoundryID(this.app);
      },
      frontMatter: () => {
        return this.app.metadataCache.getFileCache(sourceFile)?.frontmatter ?? {}
      }
      // expose only what's needed
    };
    html = runJavaScript(settings.jsCode, html, scriptApi) ?? html;
  }
  // set the cleaned html to the foundryHtml object
  FoundryHtml.html = settings.footerAndHeader[0] + html + settings.footerAndHeader[1]; //let us add additional html informations if desired at the end of rendering AND cleaning again
  //TODO: Investigate if footer and Header should not only make sense for file export OR if there needs to be a setting to decide to add it to clippboard,foundry export,file export
  //Probably there should be an array with the type of export and it should be selectable on the modal ==> This is a good solution!
  FoundryHtml.obsidianFileObj = sourceFile; // set the obsidian file object to the foundryHtml object so file and conten information stay together
  return FoundryHtml; //return cleaned html
}


function runJavaScript(codeString: string, html: string, api: any): string {
  debug.log("JavaScript execution was started")
  try {
    /* creates a function, the function code allways is the last parameter
    The function looks like this 
    function(html, api) {
      ... codeString .....
      } 
    */
    const fn = new Function('html', 'api', codeString);
    // In a second step the function is called with two parameters one parameter is the html the other the exposed functions
    const returnHTML = fn(html, api)
    // make sure the html is returned even if the function writer did not set a return statement
    return returnHTML ?? html;
  } catch (e) {
    console.error("Script execution failed:", e);
    return `Error: ${(e as Error).message}`;
  }
}

// function to replace href picture links in the html based on an array of collected pictures
export function replacePictureLinks(
  html: string,
  settings: MarkdownToFoundrySettings,
  pictureList: ObsidianPicture[]
): string {

  debug.log("Picture link replacement was started: [replacePictureLinks]");
  if (!settings.encodePictures) {
    if (pictureList.length > 0) {
      for (let i = 0; i < pictureList.length; i++) {
        const foundryPicturePath = pictureList[i]?.FoundryPictureHashPath ?? ""; // Foundry picture path with hashnamed picture
        const replacementString = encodeURIComponent(foundryPicturePath); //the Foundry path needs to be transformed to an URI string
        const dynamicStringToMatch = pictureList[i]?.ObsidianPictureURI ?? ""; //URI path string of Obsidian picture
        // Escape the string so it's safe for regex
        const escapedPattern = escapeRegex(dynamicStringToMatch);
        // Create a dynamic global regex
        const regex = new RegExp(escapedPattern, "g");
        // Replace all occurrences
        html = html.replace(regex, replacementString); // find all Obsidian paths and replpace with the Foundry paths
      }
    }
  }
  return html; //return html with picture path regex changes
}

function escapeRegex(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// function to replace strings in the html according to an array of rules
function replaceInHTMLWithRegex(html: string, settings: MarkdownToFoundrySettings): string {
  
  debug.log("Regex replacements according to rules array started: [replaceInHTMLWithRegex]");
  
  if (settings.rulesForRegex) {
    for (let i = 0; i < settings.rulesForRegex.length; i++) {
      const singleRuleSet = settings.rulesForRegex[i];
      if (singleRuleSet[0]) {
        let { regexPattern, regexFlags } = parseRegexPattern(singleRuleSet[0]); //parse the input to a regex
        const regex = new RegExp(regexPattern, regexFlags); //create a regex object
        const replacementString = singleRuleSet[1];
        html = html.replace(regex, replacementString); //replace inside of the html an do this for all rules
        regexPattern = ""; //make sure regex input is empty
        regexFlags = ""; //make sure regex input is empty
      }
    }
  }
  return html; //return html with rule based regex changes
}

//create a valid regex
function parseRegexPattern(input: string): { regexPattern: string; regexFlags: string } {
  debug.log("Parsing regex expression to be a valid regex: [parseRegexPattern]")
  const match = input.match(/(.*)\/([gimsuy]*)$/);
  if (!match) throw new Error("Invalid regex input");
  return {
    regexPattern: match[1],
    regexFlags: match[2] || "",
  };
}

//function to modify tags - allows to create tags for callouts and also necessary to work around Foundry bugs in html sanitizing which are not corrected by foundry devs
function replaceTag(parent: HTMLElement, settings: MarkdownToFoundrySettings) {
  
  debug.log("Replacing HTML tag elements in node modus: [replaceTag]");
  
  if (settings.rulesForTags) {
    for (let i = 0; i < settings.rulesForTags.length; i++) {
      const singleRuleSet = settings.rulesForTags[i];
      if (singleRuleSet[0]) {
        // Convert NodeList to Array to avoid issues with dynamic updates
        const tagList = Array.from(parent.querySelectorAll(singleRuleSet[0]));

        tagList.forEach(element => {
          const innerHTMLold = element.innerHTML;
          //node operations could also be used here instead of innerHTML but I do not need to clone the children
          // as I do not need to retain events or other properties of the element
          if (isEmpty(singleRuleSet[1])) {
            element.remove();
            return;
          }
          // Create new element
          const newElement = element.createEl(singleRuleSet[1] as keyof HTMLElementTagNameMap);
          newElement.innerHTML = innerHTMLold;
          // Copy attributes
          element.getAttributeNames().forEach(attr => {
            if (element.hasAttribute(attr)) {
              const attrValue = element.getAttribute(attr);
              if (attrValue) {
                newElement.setAttribute(attr, attrValue);
              }
            }
          });
          // Replace element
          element.replaceWith(newElement);
          // Recursively process nested elements by calling the function again
          // This is necessary to ensure that nested elements are also processed
          if (newElement.children.length > 0) {
            replaceTag(newElement, settings);
          }
        });
      }
    }
  }
}

//TODO: resolve internal links (potentially) differently if a file export is used
function resolveInternalLinks(parent: HTMLElement, settings: MarkdownToFoundrySettings, sourceFile?: TFile): FoundryHtmlLinkInformation[] {
  
  debug.log("Resolving of internal Obsidian wikilinks has started: [resolveInternalLinks]");
  
  let linkaArray: FoundryHtmlLinkInformation[] = [];
 
  if (settings.internalLinkResolution) {
    const activeFile = sourceFile ?? this.app.workspace.getActiveFile();
    const links = parent.querySelectorAll("a.internal-link"); //get all internal links which are of tag type anker ==>a and match the class "internal-link" these are NOT the picture links

    links.forEach(link => {
      // init foundryLink object which we will later export to foundry
      let foundryLink: FoundryHtmlLinkInformation = {
        obsidianNoteUUID: "",
        linkPath: "",
        linkText: "",
        linkDestinationUUID: "",
        isAnkerLink: true,
        ankerLink: "",
        linkResolved: false,
      };
      //IF  an anker is used the wikilink will be "SomeMDfile#SomeHeading" OR JUST #SomeHeading
      //so get the first group, resolve the file path and then replace the first group in the original href with the resolved path
      //Foundry cannot utilize this but for an export as HTML it is usefull and the standard as I understand
      const href = link.getAttribute("href") as string;

      const splitLink = (input: string) => {
        const hashAtIndex = input.indexOf('#');

        if (hashAtIndex === -1) {
          // No hash found, return entire string as path and empty/no anker
          return {
            path: input,
            anker: ''
          };
        }

        // Split at the first hash and return the path and the remaining anker information
        const path = input.substring(0, hashAtIndex);
        const anker = input.substring(hashAtIndex);

        return {
          path,
          anker
        };
      };

      const splitLinkResult = splitLink(href)
      const ankerInfo = splitLinkResult.anker //store the anker information which can contain several hashes
      let keepLink = true;
      //TODO: Implement separate fields for all informations like anker and resolved address once html export to file is due
      if (ankerInfo) {
        foundryLink.linkText = link.textContent ?? ""; // set the link text to the text content
        foundryLink.ankerLink = ankerInfo
      }

      const hrefToResolve = splitLinkResult.path //store the path part
      if (hrefToResolve) { // if there is something to resolve resolve it
        const targetFile = this.app.metadataCache.getFirstLinkpathDest(hrefToResolve, activeFile.path); // get the Obsidian file object according to the path part of the link
        const targetFilePath = targetFile.path //store the file path of the resolved obsidian file object

        if (targetFile) {
          if (settings.foundryWriteFrontmatter) {
          foundryLink.linkDestinationUUID = generateIdForFile(this.app, targetFile) // generade ID for notes which are link destinations or return the existing UUID of the found file. 
          // This will unqiquely fix the destination link to the right note even if a file/note is later moved in the path structure of obsidian
            } else {foundryLink.linkDestinationUUID = ""}
        }
        foundryLink.linkPath = targetFilePath; // set the link path to the resolved obsidian file object path
        foundryLink.linkText = link.textContent ?? ""; // set the link text to the text content of the link
        foundryLink.isAnkerLink = false // if it is a normal link we change anker link back not to be an anker link
        link.setAttribute("href", targetFilePath);
        if (ankerInfo) {
          link.setAttribute("href", targetFilePath + ankerInfo); //set the href tag to a clean path+anker logic //Maybe href should be uri encoded
          foundryLink.isAnkerLink = true; // set the isAnkerLink to true if the link is an anchor link
          foundryLink.ankerLink = ankerInfo; // set the anker link to the part after the resolved file path
        }
        if (targetFile.extension !== "md") {// mark the link to be dropped if it is not a markdown file
          keepLink = false;
        }
      }

      // the special case that it is a purely internal link on the same note is handled on the foundry macro which replaces the links

      // make sure only markkdown targets and anker links are used as links
      if (keepLink || foundryLink.isAnkerLink) {
        linkaArray.push(foundryLink); // push the foundry link to the link array list array
      }
    });
  }
  return linkaArray; // return the array of Foundry links
}

/** remove all child nodes that don't have any content (removes empty paragraphs left by comments) */
// TODO: Think about making this more flexible and/or include other tags ? IF necessary
function removeEmptyContainer(parent: HTMLElement) {
  debug.log("Removing of all p and div tags with no innter text: [removeEmptyContainer]")
  parent.querySelectorAll("p, div").forEach(node => {
    if (isEmpty(node.innerHTML)) {
      node.remove();
    }
  });
}

/** Remove frontmatter header */
function removeFrontMatter(parent: HTMLElement, settings: MarkdownToFoundrySettings) {
  
  debug.log("Removing frontmatter information: [removeFrontMatter]");
  
  if (settings.removeFrontmatter) {
    const frontmatterNodes = parent.querySelectorAll(".frontmatter, .frontmatter-container");
    frontmatterNodes.forEach(node => node.remove());
  }
}

/** Remove all irrelevant classes of in nodes */
function removeAttributes(parent: HTMLElement, settings: MarkdownToFoundrySettings) {
  
  debug.log("Removing all attributes and classes - leaving only selected: [removeAttributes]");
  
  const elements = parent.querySelectorAll<HTMLElement>("*"); //select all html elements/nodes

  elements.forEach(element => {
    const attributesToRemove: string[] = [];
    // create a positiv list of all classes which are to be keept
    const classesToKeep: string[] = Object.assign([], settings.classList).filter(cls =>
      element.classList.contains(cls)
    );

    const attributes = element.attributes; // get all attributes of the element

    // loop through all attributes and check if they are in the settings attributeList
    for (let i = 0; i < attributes.length; i++) {
      // get the name of the attribute and convert it to lowercase
      const attrName = attributes[i].name.toLowerCase();
      // if the attribute found is not in the attributeListe, add them to the attributesToRemove array
      if (!settings.attributeList.contains(attrName)) {
        attributesToRemove.push(attrName);
      }
    }
    // remove all attributes that are not allowed
    attributesToRemove.forEach(attr => element.removeAttribute(attr));
    // read classes to keep and add them again after they have been removed in the attribute purge
    element.addClasses(classesToKeep);
  });
}

/** Convert internal Images to base64 string */
async function convertImages(parent: HTMLElement, settings: MarkdownToFoundrySettings, sourceFile?: TFile) {
  
  debug.log("Base64 encoding started: [convertImages]");
  
  if (settings.encodePictures) {
    const images = parent.querySelectorAll('img:not([src^="http"])') as NodeListOf<HTMLImageElement>;
    for (let i = 0; i < images.length; i++) {
      const image = images[i];
      image.src = await toBase64(image.src); // if encoding is set to true use base64 encoding and ignory file path converting
      //img.src is the src attribute of the image element and holds the path to the image
      //for foundry add is as uuid name  AND/OR adjust the alt attribute (it also holds the creation date of the picture)
      //<img alt="Cuil.png" src="app://1f8bb40c2ff2bacb6e85757575d1cfa3a442/%5C%5Cobsidian/Obsidian/ObsidianDev/DSAObsidianDev/DSA%20Kampagne/04%20NPC/Zum%20Drachent%C3%B6ter/attachments/Cuil.png?1736376801556">
    }
  }

  // changing internal links to external paths as needed for html and foundry export only partly "works". There are issues with the (probable?) caching of the filepaths in Obsidian. I got
  // Internal error "ERR_FILE_NOT_FOUND" it looks as if changing the src on the html directly triggers Obsidian to  try to fetch that file....
  // This functionality  was moved to a  regex replacement of the final html. This is also more flexible to allow to differentiate between foundry and html file export
}

/** Read a file from an uri and turn it into a base64 string */
//img.src is the src attribute of the image element and holds the path to the image
export async function toBase64(srcFilePath: string) {
  return await fetch(srcFilePath)
    .then(res => res.blob())
    .then(
      blob =>
        new Promise<FileReader>((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr);
          fr.onerror = err => reject(err);
          fr.readAsDataURL(blob);
        })
    )
    .then(fr => fr.result as string);
}

